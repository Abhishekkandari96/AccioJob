//***************************************
Aggresive Cows
Given an array of length N, where each element denotes the position of a stall. You are also given an integer K which denotes the number of cows that are aggressive. To prevent the cows from hurting each other, you need to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. Return the largest minimum distance.

Input Format
The first line contains 'N' and 'K' denoting the number of elements in the array/list and the number of aggresive cows.

The second line contains 'N' single space-separated integers denoting the elements of the array.

"NOTE: " You do not need to print anything; it has already been taken care of.

Just Complete the funtion.

Output Format
Print the majority element.

Example 1
Input

3 2
1 2 3
Output:

2
Explanation:

The largest minimum distance will be 2 when 2 cows are placed at positions {1,3}.

Example 2
Input

6 4
0 3 4 7 10 9
Output:

3
Explanation:

The largest distance will be 3 when 4 cows are placed at positions {0,3,7,10}.

Constraints
2<=N<=20000

2<=C<=N

0<=arr[i]<=10^9

Topic Tags

//****************************************

import java.util.*;
import java.lang.*;
import java.io.*;

class Solution {
    /*
    approach-
    
    step.1-sort array, to know distance between consiqutive cows(cow will be placed accoding to their position number, so that we able to know which cow has agression from which cow);
    step 2-find sample space =start : 1;smallest distace(min distance between to stalls of cow(possible))
                            ending: arr[length-1]-arr[0]; highest distance
    step 3- allocate a variable to store ans, and we have to maximise this
    step 4- binary search
             conditions-
             step(a)-make a function named as possibletoPlaceXCows()
                     =>this will return true based on, if cow is placed with maximum distance between them
                     step(i)-initialise no of cowplaced=1;last position placed=arr[0];
                     step (ii)-inside loop(start from 1, as we have placed cow at 0)
                              condition;
                              1-if current position-last position is greter or equal then  min distance , increase cowPlaced, and update last postion to i;
                     step(iii)- if cowplaced are are more  then or equal to no of total cows return true, else false;
                      
                                                
             step(b)-if(possibletoPlaceXCows==true)=>allocateans =mid; and search for next higher ans possible in rhs;
             if(possibletoPlaceXCows==false)=> search in lhs ,as current capacity is less
    step 5=come out of loop and return alloacteans;
                            
    */
    public static boolean possibletoPlaceXCows(int arr[],int distance, int totalCows){
        int cowPlaced=1;
        int lastPositionPlaced=arr[0];
        for(int i=1;i<arr.length;i++){
            if(arr[i]-lastPositionPlaced>=distance){
                cowPlaced++;
                lastPositionPlaced=arr[i];
            }
        }
        if(cowPlaced>=totalCows){
            return true;
        }
        return false;
        
    }
    public static int aggressiveCows(int arr[],int cows){
 //step.1-sort array, to know distance between consiqutive cows(cow will be placed accoding to their position number, so that we able to know which cow has agression from which cow);
      Arrays.sort(arr);
 //step 2-find sample space 
    //start : 1;smallest distace(min distance between to stalls of cow(possible))
        int start=1;
    // ending: arr[length-1]-arr[0]; highest distance
        int end=arr[arr.length-1]-arr[0];
// step 3- allocate a variable to store ans, and we have to maximise this
      int ans=0;
//step 4- binary search
        
        while(start<=end){
            //mid dinoting distance
            int mid=(start+end)/2;
           // if(possibletoPlaceXCows==true)=>allocateans =mid; and search for next higher ans possible in rhs;
            if(possibletoPlaceXCows(arr,mid,cows)){
                ans=mid;
                start=mid+1;
            }
            else{
                //if(possibletoPlaceXCows==false)=> search in lhs ,as current capacity is less
                end=mid-1;
            }
        }
        return ans;

       
    }


}

class Main {
        public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int k = sc.nextInt();
		int[] nums = new int[n];
		for (int i = 0; i < n; i++)
		{
			nums[i] = sc.nextInt();
		}
        Solution obj=new Solution();
		System.out.println(obj.aggressiveCows(nums,k));

    }
}
