//********************************
Top view of Binary tree
You are given a pointer to the head of the binary tree. You have to print the top view of the tree from left to right.

NOTE: Top view of a binary tree is the set of nodes visible when the tree is viewed from the top.

You need to complete the given function. The input and printing of output will be handled by the driver code.

Input Format
The first line contains the number of test cases.

For each test case: The line contains a string giving array representation of a tree, if the root has no children give N in input.

Output Format
For each test case print the right view of the binary tree.

Example 1
Input

1
1 2 3

      1
    /   \
   2     3

Output

2 1 3
Explanation

'2', '1' and '3' are visible from the top view.

Example 2
Input

1
1 2 3 4

      1
    /   \
   2     3
  /
4
Output

4 2 1 3
Explanation

'4', '2', '1' and '3' are visible from the top view.

Constraints
1 <= T <= 10

1 <= N <= 10000

Topic Tag
//************************
class Pair{
    int data;
    Node node;
    Pair(int data,Node node){
        this.data=data;
        this.node=node;
        
    }
}
class Solution
{
    //Function to return a list of nodes visible from the top view 
    //from left to right in Binary Tree.
    static ArrayList<Integer> topView(Node root)
    {
        // add your code
        ArrayList<Integer>list= new ArrayList<Integer>();
         if(root == null) return list;

        Queue<Pair> q=new LinkedList<>();
        q.add(new Pair(0,root));
        HashMap<Integer,Integer> hm=new HashMap<>(); 
        int min=Integer.MAX_VALUE;
        int max=Integer.MIN_VALUE;
        
        while(q.size()>0){
           int size = q.size();
            for(int i = 0; i < size; i++){
            Pair temp=q.remove();
            int val=temp.data;
            
            Node pNode=temp.node;
            
            min=Math.min(min,val);
            max=Math.max(max,val);
             
             if(!hm.containsKey(val)) {
                    hm.put(val, pNode.data);
                }

            
            
         if(pNode.left!=null) q.add(new Pair(val-1,pNode.left));
         if(pNode.right!=null) q.add(new Pair(val+1,pNode.right));
        }
        }
        for(int i=min;i<=max;i++){
            list.add(hm.get(i));
        }
        return list;
        
    }
}
